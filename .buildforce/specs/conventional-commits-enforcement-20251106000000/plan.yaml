version: "0.0.32"
id: conventional-commits-enforcement-20251106000000-plan
name: "Implementation Plan for Conventional Commits Enforcement"
spec_id: "conventional-commits-enforcement-20251106000000"
type: implementation-plan
status: draft
created: "2025-11-06"
last_updated: "2025-11-06"

# ARCHITECTURE OVERVIEW

approach: |
  Implement a dual-layer enforcement strategy with local git hooks (husky) providing fast feedback during
  development and GitHub Actions providing remote validation that cannot be bypassed. Install commitlint
  with @commitlint/config-conventional for standardized commit message validation aligned with the project's
  existing 11 commit types used in release note generation. Add commitizen for improved developer experience
  with interactive commit prompts. Create validation hooks for both commit messages (commit-msg) and branch
  naming (pre-push), ensuring all enforcement works with TypeScript ESM project configuration.

technology_stack:
  - "@commitlint/cli + @commitlint/config-conventional - Industry-standard commit message linting with Conventional Commits preset"
  - "husky v9+ - Modern git hooks manager using prepare script (no husky install required)"
  - "commitizen + cz-conventional-changelog - Interactive CLI for guided commit message creation"
  - "GitHub Actions - Remote PR branch name validation as safety net"
  - "Bash scripts - Branch naming validation in pre-push hook with clear error messages"

decisions:
  - decision: "Use @commitlint/config-conventional as base configuration"
    rationale: "Provides battle-tested rules for Conventional Commits spec. Aligns with project's existing informal usage and release workflow expectations. Reduces custom configuration needed."

  - decision: "Configure commitlint.config.js with ES module syntax (export default)"
    rationale: "Project uses TypeScript with NodeNext modules. ES module syntax ensures compatibility and consistency with project's module system."

  - decision: "Implement branch validation in pre-push hook, not pre-commit"
    rationale: "pre-push validates before sharing code, avoiding annoyance of branch name rejection after work is done. Allows local commits on any branch, only enforces on push."

  - decision: "Use regex pattern for branch naming instead of npm package"
    rationale: "Simple bash regex validation is fast, has zero dependencies, and provides clear error messages. More maintainable than adding another npm package for basic validation."

  - decision: "Add GitHub Actions branch validation workflow"
    rationale: "Provides enforcement safety net for PRs created via web UI or commits pushed without running local hooks (--no-verify). Ensures all PRs meet naming standards."

  - decision: "Include commitizen with cz-conventional-changelog adapter"
    rationale: "Significantly improves DX for contributors unfamiliar with Conventional Commits. Interactive prompts guide users to valid commit messages, reducing rejected commits and frustration."

# FILE STRUCTURE

files_to_create:
  - commitlint.config.js
  - .husky/commit-msg
  - .husky/pre-push
  - .github/workflows/branch-naming.yml
  - .czrc

files_to_modify:
  - path: "package.json"
    change_type: "edit"
    description: "Add devDependencies (commitlint, husky, commitizen), add 'prepare' and 'commit' scripts"

  - path: "README.md"
    change_type: "edit"
    description: "Document commit conventions and commitizen usage in Contributing section"

# IMPLEMENTATION PHASES

phase_1:
  name: "Install Dependencies and Configure Commitlint"
  description: |
    Install all required npm packages as devDependencies and create commitlint configuration file with
    custom rules matching the project's 11 commit types. This establishes the foundation for commit
    message validation.

  tasks:
    - [ ] Install @commitlint/cli and @commitlint/config-conventional as devDependencies
      spec_refs: [FR1]
      files: [package.json]
      notes: "Use npm install --save-dev @commitlint/cli @commitlint/config-conventional"

    - [ ] Create commitlint.config.js with ES module export and custom type-enum rule
      spec_refs: [FR2, FR3, FR10, NFR4]
      files: [commitlint.config.js]
      notes: "Configure 11 types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert"

    - [ ] Test commitlint configuration by running npx commitlint with valid/invalid messages
      spec_refs: [FR10, NFR2]
      files: []
      notes: "Verify error messages are clear and include examples"

  validation:
    - [ ] All phase_1 tasks completed
    - [ ] commitlint.config.js uses ES module syntax (export default)
    - [ ] Running 'echo "invalid" | npx commitlint' fails with helpful error
    - [ ] Running 'echo "feat: test" | npx commitlint' succeeds
    - [ ] Spec requirements covered: [FR1, FR2, FR3, FR10, NFR4]

phase_2:
  name: "Setup Husky and Commit Message Validation Hook"
  description: |
    Initialize husky v9+ using the prepare script approach and create commit-msg hook to validate
    commit messages with commitlint. This provides local enforcement with fast feedback.

  tasks:
    - [ ] Install husky as devDependency
      spec_refs: [FR1]
      files: [package.json]
      notes: "Use npm install --save-dev husky"

    - [ ] Add 'prepare' script to package.json running 'husky' command
      spec_refs: [FR4, AC10]
      files: [package.json]
      notes: "Script: 'prepare': 'husky' - runs automatically after npm install"

    - [ ] Run npm run prepare to initialize husky
      spec_refs: [FR4]
      files: [.husky/]
      notes: "Creates .husky/ directory with _/ folder containing husky.sh"

    - [ ] Create .husky/commit-msg hook calling commitlint
      spec_refs: [FR4, NFR1]
      files: [.husky/commit-msg]
      notes: "Hook content: npx --no -- commitlint --edit $1"

    - [ ] Make commit-msg hook executable (chmod +x)
      spec_refs: [FR9, AC9]
      files: [.husky/commit-msg]
      notes: "Ensure hook is executable and committed to repository"

    - [ ] Test commit-msg hook with invalid commit message
      spec_refs: [AC1, NFR2]
      files: []
      notes: "git commit -m 'bad message' should be rejected with clear error"

    - [ ] Test commit-msg hook with valid conventional commit
      spec_refs: [AC2]
      files: []
      notes: "git commit -m 'feat: test' should be accepted"

  validation:
    - [ ] All phase_2 tasks completed
    - [ ] .husky/commit-msg hook exists and is executable
    - [ ] package.json contains 'prepare': 'husky' script
    - [ ] Invalid commits are rejected with helpful error messages
    - [ ] Valid conventional commits are accepted
    - [ ] Spec requirements covered: [FR1, FR4, FR9, AC1, AC2, AC9, AC10, NFR1, NFR2]

phase_3:
  name: "Implement Branch Naming Validation"
  description: |
    Create pre-push hook to validate branch names against regex pattern matching commit type prefixes.
    Includes clear error messages with examples and allows protected branches (main, staging, dev).

  tasks:
    - [ ] Create .husky/pre-push hook with branch name validation script
      spec_refs: [FR5, NFR2, NFR5]
      files: [.husky/pre-push]
      notes: "Use bash regex pattern: ^(main|staging|dev)$|^(feat|fix|chore|...)/.+$"

    - [ ] Add helpful error message with examples to pre-push hook
      spec_refs: [NFR2, AC11]
      files: [.husky/pre-push]
      notes: "Show allowed patterns and example: feat/add-conventional-commits"

    - [ ] Make pre-push hook executable (chmod +x)
      spec_refs: [FR9, AC9]
      files: [.husky/pre-push]
      notes: "Ensure hook is executable and committed to repository"

    - [ ] Test pre-push hook with invalid branch name
      spec_refs: [AC3, NFR2]
      files: []
      notes: "Create branch 'random-name', git push should be rejected with clear error"

    - [ ] Test pre-push hook with valid feat/ branch name
      spec_refs: [AC4]
      files: []
      notes: "Create branch 'feat/new-feature', git push should be accepted"

    - [ ] Test pre-push hook allows protected branches (main, staging, dev)
      spec_refs: [AC12]
      files: []
      notes: "Checkout main branch, git push should be accepted without prefix validation"

  validation:
    - [ ] All phase_3 tasks completed
    - [ ] .husky/pre-push hook exists and is executable
    - [ ] Invalid branch names are rejected with clear examples
    - [ ] Valid branch names (with type prefix) are accepted
    - [ ] Protected branches (main, staging, dev) are allowed
    - [ ] Hook executes quickly (< 1 second)
    - [ ] Spec requirements covered: [FR5, FR9, AC3, AC4, AC9, AC11, AC12, NFR1, NFR2, NFR5]

phase_4:
  name: "Setup Commitizen for Interactive Commit Prompts"
  description: |
    Install and configure commitizen with cz-conventional-changelog adapter to provide interactive
    commit message creation. Improves DX by guiding contributors through valid commit format.

  tasks:
    - [ ] Install commitizen and cz-conventional-changelog as devDependencies
      spec_refs: [FR1, FR6]
      files: [package.json]
      notes: "Use npm install --save-dev commitizen cz-conventional-changelog"

    - [ ] Create .czrc configuration file with cz-conventional-changelog path
      spec_refs: [FR6, NFR3]
      files: [.czrc]
      notes: "Configure path to cz-conventional-changelog adapter"

    - [ ] Add 'commit' script to package.json running 'cz'
      spec_refs: [FR7]
      files: [package.json]
      notes: "Script: 'commit': 'cz' - launches commitizen interactive prompt"

    - [ ] Test commitizen by running npm run commit
      spec_refs: [AC5, NFR3]
      files: []
      notes: "Verify interactive prompt shows all 11 commit types with descriptions"

    - [ ] Verify commitizen commits pass commitlint validation
      spec_refs: [FR6, AC5]
      files: []
      notes: "Complete commitizen flow and confirm commit-msg hook accepts it"

  validation:
    - [ ] All phase_4 tasks completed
    - [ ] .czrc configuration file exists
    - [ ] package.json contains 'commit': 'cz' script
    - [ ] Running 'npm run commit' launches interactive prompt
    - [ ] Interactive prompt shows all 11 commit types
    - [ ] Commits created via commitizen pass commitlint validation
    - [ ] Spec requirements covered: [FR1, FR6, FR7, AC5, NFR3]

phase_5:
  name: "Create GitHub Actions Branch Naming Workflow"
  description: |
    Create GitHub Actions workflow to validate branch names on pull requests. Provides remote enforcement
    layer that cannot be bypassed via --no-verify or web UI PR creation.

  tasks:
    - [ ] Create .github/workflows/branch-naming.yml workflow file
      spec_refs: [FR8, NFR6]
      files: [.github/workflows/branch-naming.yml]
      notes: "Trigger on PR events: opened, edited, synchronize, reopened"

    - [ ] Add branch name validation job using github.head_ref
      spec_refs: [FR8]
      files: [.github/workflows/branch-naming.yml]
      notes: "Use bash regex to validate branch name pattern"

    - [ ] Configure workflow to show clear pass/fail status in PR checks
      spec_refs: [NFR6, AC6, AC7]
      files: [.github/workflows/branch-naming.yml]
      notes: "Exit 1 on invalid branch with error message, exit 0 on valid"

    - [ ] Test workflow by creating PR with invalid branch name
      spec_refs: [AC6]
      files: []
      notes: "Create PR from branch 'update-readme', verify workflow fails"

    - [ ] Test workflow by creating PR with valid branch name
      spec_refs: [AC7]
      files: []
      notes: "Create PR from branch 'docs/update-readme', verify workflow passes"

  validation:
    - [ ] All phase_5 tasks completed
    - [ ] .github/workflows/branch-naming.yml workflow exists
    - [ ] Workflow triggers on PR events
    - [ ] Invalid branch names fail PR check with clear error
    - [ ] Valid branch names pass PR check
    - [ ] PR check status is visible in GitHub UI
    - [ ] Spec requirements covered: [FR8, AC6, AC7, NFR6]

phase_6:
  name: "Documentation and Final Testing"
  description: |
    Update README with commit conventions and commitizen usage documentation. Perform comprehensive
    testing across all acceptance criteria to ensure enforcement works correctly.

  tasks:
    - [ ] Add Contributing section to README documenting conventional commits
      spec_refs: []
      files: [README.md]
      notes: "Explain commit format, show examples, list allowed types"

    - [ ] Document commitizen usage in README (npm run commit)
      spec_refs: []
      files: [README.md]
      notes: "Explain interactive commit flow for new contributors"

    - [ ] Document branch naming conventions in README
      spec_refs: []
      files: [README.md]
      notes: "Show allowed prefixes and example branch names"

    - [ ] Run comprehensive test suite covering all 12 acceptance criteria
      spec_refs: [AC1-AC12]
      files: []
      notes: "Verify all AC pass: invalid/valid commits, invalid/valid branches, commitizen, GitHub Actions, protected branches"

    - [ ] Verify .gitignore does not exclude .husky/ directory
      spec_refs: [FR9]
      files: [.gitignore]
      notes: "Ensure husky hooks are committed to repository"

    - [ ] Test enforcement works on macOS, Linux, and Windows Git Bash
      spec_refs: [NFR5]
      files: []
      notes: "Verify hooks are portable across development environments"

  validation:
    - [ ] All phase_6 tasks completed
    - [ ] README contains commit and branch naming documentation
    - [ ] All 12 acceptance criteria pass
    - [ ] .husky/ directory is committed (not in .gitignore)
    - [ ] Enforcement works across all environments
    - [ ] Spec requirements covered: [FR9, AC1-AC12, NFR5]

# DEVIATION LOG

deviations: []

# TESTING GUIDANCE

testing:
  automated_tests:
    - test_file: "N/A - Manual validation testing"
      what: "Git hooks and GitHub Actions validation"
      command: "Manual git commit and git push tests"

  manual_tests:
    - scenario: "Test commit message validation"
      steps: |
        1. git commit -m "invalid message" → Should be rejected by commit-msg hook
        2. git commit -m "feat: add new feature" → Should be accepted
        3. git commit -m "fix: resolve bug" → Should be accepted
        4. git commit -m "docs: update README" → Should be accepted
        5. Verify error messages are clear and include examples

    - scenario: "Test branch naming validation"
      steps: |
        1. Create branch: git checkout -b random-name
        2. git push → Should be rejected by pre-push hook with error
        3. Create branch: git checkout -b feat/new-feature
        4. git push → Should be accepted
        5. Checkout main branch and push → Should be accepted (protected branch)

    - scenario: "Test commitizen interactive flow"
      steps: |
        1. Run: npm run commit
        2. Verify interactive prompt appears with 11 commit types
        3. Select 'feat', enter description, complete flow
        4. Verify commit is created and passes commitlint validation

    - scenario: "Test GitHub Actions PR validation"
      steps: |
        1. Create branch: update-readme (invalid)
        2. Push and create PR
        3. Verify GitHub Actions check fails with clear error
        4. Create branch: docs/update-readme (valid)
        5. Push and create PR
        6. Verify GitHub Actions check passes

# VALIDATION CRITERIA

success_metrics:
  - "100% of invalid commits rejected by commit-msg hook with clear error messages"
  - "100% of valid conventional commits accepted by commit-msg hook"
  - "100% of invalid branch names rejected by pre-push hook"
  - "100% of valid branch names accepted by pre-push hook"
  - "Commitizen interactive prompt displays all 11 commit types"
  - "GitHub Actions PR checks correctly validate branch naming"
  - "All hooks execute in < 1 second (fast feedback)"
  - "Documentation in README provides clear guidance for contributors"

spec_coverage:
  - FR1: "⏳ Phase 1: Task 1, Phase 2: Task 1, Phase 4: Task 1"
  - FR2: "⏳ Phase 1: Task 2"
  - FR3: "⏳ Phase 1: Task 2"
  - FR4: "⏳ Phase 2: Tasks 2-4"
  - FR5: "⏳ Phase 3: Task 1"
  - FR6: "⏳ Phase 4: Tasks 1-2, 5"
  - FR7: "⏳ Phase 4: Task 3"
  - FR8: "⏳ Phase 5: Tasks 1-2"
  - FR9: "⏳ Phase 2: Task 5, Phase 3: Task 3, Phase 6: Task 5"
  - FR10: "⏳ Phase 1: Tasks 2-3"
  - NFR1: "⏳ Phase 2: Task 4, Phase 3: Task 1"
  - NFR2: "⏳ Phase 1: Task 3, Phase 2: Task 6, Phase 3: Tasks 2, 4"
  - NFR3: "⏳ Phase 4: Tasks 2, 4"
  - NFR4: "⏳ Phase 1: Task 2"
  - NFR5: "⏳ Phase 3: Task 1, Phase 6: Task 6"
  - NFR6: "⏳ Phase 5: Task 3"
  - AC1: "⏳ Phase 2: Task 6"
  - AC2: "⏳ Phase 2: Task 7"
  - AC3: "⏳ Phase 3: Task 4"
  - AC4: "⏳ Phase 3: Task 5"
  - AC5: "⏳ Phase 4: Tasks 4-5"
  - AC6: "⏳ Phase 5: Task 4"
  - AC7: "⏳ Phase 5: Task 5"
  - AC8: "⏳ Phase 1: Task 2"
  - AC9: "⏳ Phase 2: Task 5, Phase 3: Task 3"
  - AC10: "⏳ Phase 2: Task 2"
  - AC11: "⏳ Phase 3: Task 2"
  - AC12: "⏳ Phase 3: Task 6"

# PROGRESS SUMMARY

overall_progress:
  phase_1: "0/3 tasks completed"
  phase_2: "0/7 tasks completed"
  phase_3: "0/6 tasks completed"
  phase_4: "0/5 tasks completed"
  phase_5: "0/5 tasks completed"
  phase_6: "0/6 tasks completed"

current_status: |
  Implementation not yet started. All phases pending. Ready to begin with Phase 1: Install dependencies
  and configure commitlint.

next_immediate_steps:
  - "Install @commitlint/cli and @commitlint/config-conventional as devDependencies"
  - "Create commitlint.config.js with ES module export and 11 commit types"
  - "Test commitlint configuration with valid and invalid messages"

# RISKS & CONSIDERATIONS

risks:
  - risk: "Husky hooks may not work on Windows environments without Git Bash"
    mitigation: "Document Git Bash requirement for Windows developers. Test hooks across platforms during Phase 6."

  - risk: "Developers may bypass hooks using --no-verify flag"
    mitigation: "GitHub Actions workflow provides remote enforcement layer. Document that --no-verify should only be used in emergencies."

  - risk: "Commitlint configuration may conflict with TypeScript ESM setup"
    mitigation: "Use ES module syntax (export default) in commitlint.config.js. Test thoroughly in Phase 1."

  - risk: "Branch naming validation may be too strict for edge cases"
    mitigation: "Pattern allows protected branches (main, staging, dev) without prefix. Can adjust regex if needed."

  - risk: "New contributors may be frustrated by rejected commits"
    mitigation: "Commitizen provides guided flow. Error messages include examples. README documentation explains conventions clearly."

# NOTES

lessons_learned:
  - "Dual enforcement (local + remote) provides best developer experience with strong guarantees"
  - "Clear error messages with examples are critical for adoption"
  - "Commitizen significantly improves DX for contributors unfamiliar with conventions"

future_enhancements:
  - "Consider adding automated version bumping based on commit types (semantic-release or standard-version)"
  - "Consider adding automated CHANGELOG.md generation from conventional commits"
  - "Consider pre-commit hooks for code linting (eslint) and formatting (prettier)"
  - "Consider commitlint validation in CI/CD for all commits, not just PR branch names"
  - "Consider custom commitizen adapter with project-specific prompts and scopes"
